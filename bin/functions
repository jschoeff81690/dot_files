#!/bin/zsh

# greps for path, filename and line number
function file-only () {
  if [ -n "$1" ]; then
    echo "Possible Usage: fxgc <pattern> | file-only "
    echo "Results in: path/to/file/filename.java:12"
    return 1
  fi

  grep -E -o '[a-zA-Z\.\/]+.java:[0-9]{0,2}'
}

function jks-to-pem(){
    if [ -z $1 ] || [ -z $2  ] ; then
        echo "Usage: $0 <sourcefile.jks> <destinationfile.pem>"
        return 1
    fi
    local jks_file=$1
    local pem_file=$2
    local p12_temp_file=${jks_file}.p12.tmp
    /usr/bin/keytool -importkeystore -srckeystore $jks_file -destkeystore $p12_temp_file -srcstoretype jks -deststoretype pkcs12
    /usr/bin/openssl pkcs12 -in $p12_temp_file -out $pem_file
    rm -f $p12_temp_file
}

function up() {
    if [ -z "$1" ] ; then
        echo "Usage: $0 <NumberOfDirectoriesUp>"
        return 1
    fi
    dir="../"
    if [ "$1" -gt 1 ] ; then
        for i in ${1} ; do
            dir=$dir"../"
        done
    fi
    echo $dir
    cd $dir
}

# Colorful man pages
function man() {
    env LESS_TERMCAP_mb=$'\E[01;31m' \
    LESS_TERMCAP_md=$'\E[01;38;5;74m' \
    LESS_TERMCAP_me=$'\E[0m' \
    LESS_TERMCAP_se=$'\E[0m' \
    LESS_TERMCAP_so=$'\E[38;5;246m' \
    LESS_TERMCAP_ue=$'\E[0m' \
    LESS_TERMCAP_us=$'\E[04;38;5;146m' \
    man "$@"
}

function math() {
    if [ -z "$1" ] ; then
        echo "Usage: $0 \"1+2\""
        echo "Usage: $0 \"1/2\""
        echo "Usage: $0 \"1*2\""
        echo "Usage: $0 \"1-2\""
    fi
    awk 'BEGIN{print '"$1"'}'
}

function a(){
    if [ -z "$1" ] ; then
        echo "Usage: $0 <session_name>"
        echo "Tmux attach: If session doesn't exist, create one."
        return
    fi
    tmux attach -t $1

    if [ -n $? ] ; then
        tmux new -s $1
    fi
}

#####
# A function designed to create/update aliases in ~/bin/aliases.tmp file.
#
# This will either create or update the alias if it exists in aliases.tmp
# A user can type 1 (or any char) to go to a frequently used dir.
# 
# If ~/bin/aliases.tmp doesn't exist, it will create and add source to zshrc. This will be the last aliases to load, overwriting ~/bin/aliases.
#####
function mark() {
    if [ -z "$1" ]; then
        echo "Usage: $0 path_to_set [number]"
        echo 'Ex1:'
        echo '$ type 1'
        echo '> 1 is an alias for ...'
        echo "$ $0 /home/$USER/work"
        echo '$ type 1'
        echo "> 1 is an alias for cd /home/$USER/work"
        echo '-----------------'
        echo 'Ex2:'
        echo '$ type 1'
        echo '> 1 is an alias for ...'
        echo '$ type 2'
        echo '> 2 not found'
        echo "$ $0 /home/$USER/work 2"
        echo '$ type 1'
        echo '> 1 is an alias for ...'
        echo '$ type 2'
        echo "> 2 is an alias for cd /home/$USER/work"
        return 1
    fi

    ALIAS_FILE=~/bin/aliases.tmp
    path_to_set=$1
    current_num=1

    # Allow user to specify the alias number
    if [ -n "$2" ] ; then
        current_num=$2
    fi

    # Check if its a relative path and append current dir.
    if [ '/' != ${path_to_set[1,1]} ] ; then
        path_to_set=$(pwd)"/"${1}
    fi

    # Check if ALIAS_FILE exists
    if [ ! -f ${ALIAS_FILE} ] ; then
        echo "##########################" > ${ALIAS_FILE}
        echo "## Changeable aliases" >> ${ALIAS_FILE}
        echo "##########################" >> ${ALIAS_FILE}
        echo "" >> ${ALIAS_FILE}

        # Make sure they're sourced in zshrc
        echo "" >> ~/.zshrc
        echo "# Source Temp aliases" >> ~/.zshrc
        echo "source ${ALIAS_FILE}" >> ~/.zshrc
    fi

    # Check if current_num is in aliases file
    # Add it or append it
    has_alias=$(grep "alias ${current_num}=" ${ALIAS_FILE})
    if [ -n "$has_alias" ] ; then
        pattern=$(echo $path_to_set | sed -e 's/[\/&]/\\&/g')
        sed -i "s/alias ${current_num}=\(.*\)/alias ${current_num}='cd $pattern'/g" ${ALIAS_FILE}
    else
        echo "" >> ${ALIAS_FILE}
        echo "# Alias for frequently used dir '${current_num}':" >> ${ALIAS_FILE}
        echo "alias ${current_num}='cd $path_to_set'" >> ${ALIAS_FILE}
    fi

    echo "Setting alias ${current_num} to 'cd ${path_to_set}'"
    alias ${curret_num}="cd ${path_to_set}"
}

#####
# A function that will perform type, which and grep for first occurrences in history.
#####
function what() {
     if [ -z "$1" ]; then
        echo "Usage: $0 string_to_test"
        echo "Will perform some info checks on a given string."
        echo "Currently will perform type, which, and grep for 10 occurrences in history."
        return 1
    fi

    type $1
    which $1
    echo "Recent use in history:"
    history | sed -r 's/^[0-9]*//g'  | grep $1 | tail -10
}

#####
# A git function that facilitates `git stash`.
#
# Allows for easier stashing, applying and viewing stashed work.
#####
stash () {
        usage=
        dry_run=
        command='stash'
        while getopts cCnNdDaAsShHlL opt
        do
                case $opt in
                        (h|H) command='usage'  ;;
                        (n|N) dry_run=1  ;;
                        (l|L) command='list'  ;;
                        (s|S) command='show'  ;;
                        (a|A) command='apply'  ;;
                        (d|D) command='drop'  ;;
                        (c|C) command='clear'  ;;
                esac
        done
        shift $((OPTIND - 1))
        git_cmd=
        case "$command" in
                (list) git_cmd="stash list | sed 's/stash@{\([0-9]\)}/\1/g'"  ;;
                (show) if [[ $1 =~ "^[0-9]+$" ]]
                        then
                                stash="stash@{$1}"
                        else
                                stash="stash^{/$1}"
                        fi
                        git_cmd="show $stash -p"  ;;
                (apply) if [[ $1 =~ "^[0-9]+$" ]]
                        then
                                stash="stash@{$1}"
                        else
                                stash="stash^{/$1}"
                        fi
                        git_cmd="stash apply $stash"  ;;
                (stash) extra=
                        if [[ $# -gt 0 ]]
                        then
                                extra="save '$*'"
                                echo $*
                        fi
                        git_cmd="stash $extra"  ;;
                (clear) git_cmd="stash clear"  ;;
                (drop) if [[ $1 =~ "^[0-9]+$" ]]
                        then
                                stash="stash@{$1}"
                        else
                                stash="stash^{/$1}"
                        fi
                        git_cmd="stash drop $stash"  ;;
                (usage) usage=1  ;;
        esac
        
        cmd="git $git_cmd"

        if [[ -n "$dry_run" ]]
        then
                echo $cmd
        elif [[ -z "$usage" ]]
        then
                eval $cmd
        fi

        if [[ $? -eq 1 ]]
        then
                usage=1
        fi

        if [ -n "$usage" ]; then
                echo "Usage: $0 [-hn] [-c CLEAR] [-d DROP] [-l LIST] [-s SHOW] [-a APPLY] STASH#"
                echo "-l    list stashes - performs `git stash list`"
                echo "-a    apply stash - performs `git stash apply stash@{STASH#}` OR `git stash apply stash^{/STASH}`"
                echo "-s    show stash - performs `git show stash@{STASH#}` OR `git stash apply stash^{/STASH}`"
                echo "-d    drop stash - perform `git stash drop stash@{STASH#}`"
                echo "-c    cleart stashes - perform `git stash clear`"
                echo "-n    dry run - display git command, do not run."
                echo "-h    display this help"
                echo "e.x. $0 -l =  git stash list"
                echo "e.x. $0 -a 1 = git stash apply stash@{1}"
                echo "e.x. $0 -s 1 = git show stash@{1}"
                echo "e.x. $0 -d 1 = git drop stash@{1}"
                echo "e.x. $0 = git stash"
                echo "e.x. $0 my first stash = git stash save 'my first stash'"
                echo "e.x. $0 \"my first stash\" = git stash save 'my first stash'"
                echo "e.x. $0 -d \"my first stash\" outputs \"git stash save 'my first stash'\""
                return 1
        fi
}

#####
# A git function that facilitates `git blame`.
#
# Allows for easier blaming :/.
#####
function blame() {
    if [ "$#" -lt 1 ]; then
        echo "Usage: $0 [-c commit] [-l line_option] filer_/path"
        echo "Usage: $0 [-c commit] [-l line_option] filer_/path"
        echo "-c    commit for git blame to starting looking back from"
        echo "-l    lines to search file for, without this param it does whole file."
        echo "      -l line_numer results in searching a single line"
        echo "      -l start-end results in searching from a start line to end line"
        return 1
    fi
  
    commit=
    lines=
    verbose=
    while getopts vVc:C:l:L: opt; do
        case $opt in
            c|C) commit=$OPTARG;;
            l|L) lines=$OPTARG;;
            v|V) verbose=1;;
        esac
    done
  
    shift $((OPTIND - 1))
    
    file_path=$1
    if [ ! -f $file_path ] ; then
        echo "Usage: $0 [-c commit] [-l line_option] filer_/path"
        echo "-c    commit for git blame to starting looking back from"
        echo "-l    lines to search file for, without this param it does whole file."
        echo "      -l line_numer results in searching a single line"
        echo "      -l start-end results in searching from a start line to end line"
        echo "-v    verbose: print git command instead of doing."
        echo "-h    print this help"
        return 1
    fi
  
    is_range=$(echo $lines | grep -)
    if [ -n "$is_range" ] ; then
        start=$(echo $lines | cut -d'-' -f1)
        end=$(echo $lines | cut -d'-' -f2)
        lines="-L${start},+"$(expr $end - $start )
    else
        if [[ -z "$lines" ]]; then
            lines=""
        else
            lines="-L${lines},+1"
        fi
    fi
  
    if [[ -z "$commit" ]] ;  then
        cmd="git blame ${lines} $file_path"
    else
        cmd="git blame ${lines} ${commit}^ -- $file_path"
    fi
  
    if [[ -z "$verbose" ]] ; then
        eval $cmd
    else
        echo $cmd
    fi
}

view_colors () {
  	if [[ -z "$1" ]]
  	then
  	    for i in {0..255}
  		  do
  			    printf "\x1b[38;5;${i}mcolour${i}\n"
  		  done
  	else
  		  printf "\x1b[38;5;${1}mcolour${1}\n"
  	fi
}
